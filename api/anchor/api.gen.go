// Package anchor provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package anchor

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi"
)

const (
	ApiKeyScopes = "ApiKey.Scopes"
)

// Anchor defines model for Anchor.
type Anchor struct {

	// BBc-1 domain ID in hexadecimal string.
	Bbc1dom string `json:"bbc1dom"`

	// BBc-1 transaction ID in hexadecimal string.
	Bbc1tx string `json:"bbc1tx"`

	// Target Bitcoin network. `Mainnet` `Testnet3` `Testnet4`(unsupported)
	Chain string `json:"chain"`

	// Timestamp embedded in the Anchor.
	Time int `json:"time"`

	// Anchor version. `1` `255`(test use only)
	Version int `json:"version"`
}

// AnchorRecord defines model for AnchorRecord.
type AnchorRecord struct {
	Anchor Anchor `json:"anchor"`

	// BBc-1 domain name that is not embedded in the Bitcoin transaction.
	Bbc1name *string `json:"bbc1name,omitempty"`

	// Bitcoin transaction ID transaction ID in hexadecimal string.
	Btctx string `json:"btctx"`

	// Comfirmations of the Bitcoin transaction.
	Confirmations int `json:"confirmations"`

	// Arbitrary string that is not embedded in the Bitcoin transaction.
	Note *string `json:"note,omitempty"`

	// Timestamp in Bitcoin block chain.
	Time int `json:"time"`
}

// Error defines model for Error.
type Error struct {

	// Error code with prefix `btcgw::`.
	Error string `json:"error"`

	// Message to the user.
	ErrorDescription *string `json:"error_description,omitempty"`
}

// BadRequest defines model for BadRequest.
type BadRequest Error

// ErrAnchorNotFound defines model for ErrAnchorNotFound.
type ErrAnchorNotFound Error

// InternalServerError defines model for InternalServerError.
type InternalServerError Error

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Gets the anchor specified by BBc-1 domain ID and BBc-1 transaction ID.
	// (GET /anchors/domains/{dom}/transactions/{tx})
	GetAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
	// Requests to update the status of the anchor specified by BBc-1 domain ID and BBc-1 transaction ID.
	// (PATCH /anchors/domains/{dom}/transactions/{tx})
	PatchAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
	// Registers an anchor with specified BBc-1 domain ID and BBc-1 transaction ID.
	// (POST /anchors/domains/{dom}/transactions/{tx})
	PostAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) GetAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PatchAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) PatchAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) PostAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, ApiKeyScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.GetAnchorsDomainsDomTransactionsTx)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.PatchAnchorsDomainsDomTransactionsTx)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.PostAnchorsDomainsDomTransactionsTx)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xYbW/bthP/KgT//xcd4NqS4+d3SZN1QdstSDNgQxHEFHm22UqkRp4Se4G++0BSku1Y",
	"XbNkHbCh7/h497vT/e6OuqdcZ7lWoNDS2T01YHOtLPjJCROX8FsBFt2Ma4Wg/JDleSo5Q6lV76PVyq1Z",
	"voKMudH/DSzojP6vtxXdC7u2d2aMNrQsyw4VYLmRuRNCZ/Rc3bJUCmKCQmKAg7wF0SEGsDDKEqaIv92l",
	"ZYeeGXOs+EqbHzV+rwslvj7CoI8ojWThNH4G2blCMIql78HcggnSvowN1izLU/DDcIUmyJd3s1mhYJ0D",
	"RxA3YacTTtw8REe2J4k/QVbMEs15YYzzY54Cs0AcEMaRFNbDffZnC9ZWGrfaWnzTaPPBFdzpRrnRORiU",
	"IeiShMdCZ264r+rkhL+MidAZk4qcnxKpyArWTACXGUuJRSPVsuvcU/uSDoaj8WTKEh7BIor7R4PhKPJz",
	"AYso8nO3H/m524+q8wIiN6cdipvcSQrSncMcPlx/Dh4apizjbu2RGGuIIqohjqMaYhzVEJOohjiMxo0J",
	"bt6Gka+YVIcQr5hZApITiVxLRRTgnTafumT+jkmlAOdkfgUWFeDRdjiYvyiULfJcGwTx3R726l4bBJQZ",
	"tCCQGVhkWU4gS0AIEM5FuAISwmHPNfEo7g8G01F/0siXCmEJxim4BWOlbrGy4mm13yXzeE7m/eFw/gJd",
	"YiksEK3SzZ4l8aGGskNdLpIGBJ19aNTVzq0s7DTx2kTGdSNLJx+BowMbMF0C10YchjxrqPBnHKwIU4Wg",
	"Ym3+3eOIO0JwxZBI69PWQ5/XgbATtPuxudJLuNFm2coD5K00OJTpiPDXeTGa9icQ89FgPBHxYjgEEbOh",
	"mIwgZkl/MBpNWTxYjMfjZDKeJknSH/LxYDQcHE3iKFlM41ErL7RaSJP51GsPsb/S2Xab6MWjnDTpH7WF",
	"p9LY8n2OTSLRMLOpTH7m54E01eROm1Q8hYJSNSqSVPNPxEd2GwWn8eiLBKmCuA6Mhh/7Pm8jR1Mj91kB",
	"9fI+fn+acC2A3ElckdzAQq7JvCqX830XVau4vlEab3zdbnNVS0V9qPcdWMuWQFD7j1NY2M9W9GonxJsm",
	"oXuo7YHf6qLuLGpxjyuawAsjcfPeJYLgm+NcvoGNG7k8T1fABDghISvQX14eX5y/fHP261Y7Czd8CZdq",
	"oeuehHHXk5QdmkoOyvqAqaRcvD1+dXbzw09vT88uQzyhNzQkmZOrV+Q1Q7hjG7qTjWnUjbuRO65zUCyX",
	"dEaPulE3oh2aM1x5+L0QLLYXMpXt3Qudlb2dQLe9e1yX7uwSfNPkIsPH0LmgM/oaMKRDexoknOpsx//2",
	"au3VGZYBgrF09uFJ3QTtBP864Fvvhmy//YZoCthtpL5m/1F2nt53tFvjufoYY/7+RqW87uw/OPpR1NIr",
	"b57Ux++V3JbO9TWg9UwOsUhswTlYuyjSdEOYEk0Hu+1OgjDfNg8C0jYAjUW9nfeTv3L05SuH75qyQ4eP",
	"Udb27vDZo8gyZjZtFufA5UKCIMmGPOSD80BbaPmExpaOUnULf116avPVIU8v3PI3pv4XmTo4LJHvGwr9",
	"azlSYbGuzBe5YAieMRYZFk1L+DX4o21LmbvQ9lud+1bnnlXnLmEpLYagIu5+Cgj2nyh38WGG+FmxAlfa",
	"yN8hCH4ebavG2Id93RJ/uHbu3mW0sx+M/xVVMdc/HLb0fRZ3yw7tsVx+go3tcQPMP/t2FwU4j7tFD9mZ",
	"EIhamJTOKHVwK6lN69289bcrF+fEN/DX5R8BAAD//43INwW0FQAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
