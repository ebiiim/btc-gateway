// Package anchor provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package anchor

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi"
)

const (
	ApiKeyScopes = "ApiKey.Scopes"
)

// Anchor defines model for Anchor.
type Anchor struct {

	// BBc-1 domain ID in hexadecimal string.
	Bbc1dom string `json:"bbc1dom"`

	// BBc-1 transaction ID in hexadecimal string.
	Bbc1tx string `json:"bbc1tx"`

	// Target Bitcoin network. `Mainnet` `Testnet3` `Testnet4`(unsupported)
	Chain string `json:"chain"`

	// Timestamp embedded in the Anchor.
	Time int `json:"time"`

	// Anchor version. `1` `255`(test use only)
	Version int `json:"version"`
}

// AnchorRecord defines model for AnchorRecord.
type AnchorRecord struct {
	Anchor Anchor `json:"anchor"`

	// BBc-1 domain name that is not embedded in the Bitcoin transaction.
	Bbc1name *string `json:"bbc1name,omitempty"`

	// Bitcoin transaction ID transaction ID in hexadecimal string.
	Btctx string `json:"btctx"`

	// Comfirmations of the Bitcoin transaction.
	Confirmations int `json:"confirmations"`

	// Arbitrary string that is not embedded in the Bitcoin transaction.
	Note *string `json:"note,omitempty"`

	// Timestamp in Bitcoin block chain.
	Time int `json:"time"`
}

// Error defines model for Error.
type Error struct {

	// Error code with prefix `btcgw::`.
	Error string `json:"error"`

	// Message to the user.
	ErrorDescription *string `json:"error_description,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get the anchor specified by BBc-1 domain ID and BBc-1 transaction ID.
	// (GET /anchors/domains/{dom}/transactions/{tx})
	GetAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
	// Request to update the status of the anchor specified by BBc-1 domain ID and BBc-1 transaction ID.
	// (PATCH /anchors/domains/{dom}/transactions/{tx})
	PatchAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
	// Register an anchor with specified BBc-1 domain ID and BBc-1 transaction ID.
	// (POST /anchors/domains/{dom}/transactions/{tx})
	PostAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) GetAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PatchAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) PatchAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) PostAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, ApiKeyScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.GetAnchorsDomainsDomTransactionsTx)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.PatchAnchorsDomainsDomTransactionsTx)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.PostAnchorsDomainsDomTransactionsTx)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xYa2/buBL9KwTv/dALuLbk+P3NaYLeoC02SLPbXRSBTZFji61EaslRYm/g/74g9bAd",
	"qdtsH8A+4k+WRHLODM85HOmecp1mWoFCS2f31IDNtLLgL35ULMdYG/kbiHNjtHE3BVhuZIZSKzqj88sL",
	"8hG2RFqSSmulWhNtiFS3LJGiSzs0BibA+OXevXu3mOcYg0LJGYK7Z3kMKXP/cJsBnVGLRqo13blfp3zs",
	"Z88VjwsEmdEZGJQFyCjiodBpE9rpKX8eEqFTJhW5OCNSkRg2TACXKUtIEchBhA1Ls8QFHwxH48mURTyA",
	"VRD2TwbDUeCvBayCwF+754G/ds+DcryAwF3TzsM0Oh4fbj4FDw1TlnF375EYK4giqCCOgwpiGFQQo6CC",
	"OAzGdQruug0jj5lUTYjXzKwByalErqUiCvBOm49dsnzDpFKAS7K8BosK8GT/d7B8liubZ5k2COJ/R9jL",
	"eW0QUKbQgkCmYJGlGYE0AiFAuBJhDKSgw1FpwlHYHwymo/6kXl8qhDUYF+AWjPWLNijsVyLl8y5Zhkuy",
	"7A+Hy2cIFklugWiVbI8yCZsRdh1q4NdcGhB09r4OVxW3zLBT87Vmxk29lo4+AEcHtsB0BVwb0aQ8q6Xw",
	"XwMrOqP/6e1V3Cs10ysFU1JQsbb6HmnEDSEYM3RqVhobNa+IcEDaY27Geg0LbdatOkDeKoPmmk4If14X",
	"o2l/AiEfDcYTEa6GQxAhG4rJCEIW9Qej0ZSFg9V4PI4m42kURf0hHw9Gw8HJJAyi1TQctepCq5U0KXMw",
	"bBP7C53uHxO9elSRJv2TNnoqjS37MzeRRMPMtkz5K7cHkkSTO20S8SUSlKoOESWafySe2W0SnIajzwqk",
	"JHFFjFofxzVvE0d9FB2rAtpPKD+acC2A3EmMSWZgJTdkGSFf381my+MSlXdxs1AaFyudq9ZS+ViLo0AP",
	"474Ba9kaCGq/ObmFY7ei1wcUd9vpg3Wb0R7UrUjT1UlAS3ncoQk8NxK3b50RFLWZZ/IVbN0/5/PloUw7",
	"tHAF+vPz+eXF81fnv+yjs2KGP4WlWmk3l2uFjCOd3e86NJEclPWEKVe5fD1/cb74/w+vz86vCj6hT7Qw",
	"mdPrF+QlQ7hjW3rgxjToht3ADdcZKJZJOqMn3aAb0A7NGMYefq8gi+0VTmV790Knu94B0W3vHjc7N3YN",
	"DqBbzXgOXQg6oy8BCzu0Z8UKZzo9qL+93vhwhqWAvlt5/3A73wIWIntsV+EL7TLYl7mw/f1mosmhc9AC",
	"fc9GZNf544wea7gtaXn1Piarb9+67G46xy1rPwgqpoLyRGBZlmy5p0Lvgy2Uugf3+QO0PIS9EI4L+BLQ",
	"+goW7CQ25xysXeVJsiVMCWIAc6PsQb9SLNZ1dB+0IpVfhLRwxBaIF0UjTtzuuGbGAAd5C6JTY2OK+Nkl",
	"ppPvj6nst2rL+wSW4aPqU5Or9v/KwnMFmww4glhUltni2nSuyH4k8SNIzCzRnOfGuEplCTALpDQ/klsP",
	"76s3BsEolpQR99FaauGi5WnKzLYg3RHnMuByJUGQaNvwJsfBNnX7Q4atnc1Vr1U3O2+3PG5656W7/eSe",
	"/w73HDQbmbe1rf2FfSv8VKg6v17za8aT4/0dHO+q5ABqkmeCIXjdWWSY1y9d38MNtW1pJC+1feoknzrJ",
	"b9xJXsFaWixoRtz8BBDsP6KhDJsHyqERPxlfw/jKt3fvHNV7+/sbx89DT3SEAePmlt7nP27sDfCr3K/A",
	"YW4rA8tNQmeUOgzl2Pqlf159xmk98uaXF5b8VLzrk5Dubna/BwAA///xhYFHcRgAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
