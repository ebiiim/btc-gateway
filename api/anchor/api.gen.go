// Package anchor provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package anchor

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi"
)

const (
	ApiKeyScopes = "ApiKey.Scopes"
)

// Anchor defines model for Anchor.
type Anchor struct {

	// BBc-1 domain ID in hexadecimal string.
	Bbc1dom string `json:"bbc1dom"`

	// BBc-1 transaction ID in hexadecimal string.
	Bbc1tx string `json:"bbc1tx"`

	// Target Bitcoin network. `Mainnet` `Testnet3` `Testnet4`(unsupported)
	Chain string `json:"chain"`

	// Timestamp embedded in the Anchor.
	Time int `json:"time"`

	// Anchor version. `1` `255`(test use only)
	Version int `json:"version"`
}

// AnchorRecord defines model for AnchorRecord.
type AnchorRecord struct {
	Anchor Anchor `json:"anchor"`

	// BBc-1 domain name that is not embedded in the Bitcoin transaction.
	Bbc1name *string `json:"bbc1name,omitempty"`

	// Bitcoin transaction ID transaction ID in hexadecimal string.
	Btctx string `json:"btctx"`

	// Comfirmations of the Bitcoin transaction.
	Confirmations int `json:"confirmations"`

	// Arbitrary string that is not embedded in the Bitcoin transaction.
	Note *string `json:"note,omitempty"`

	// Timestamp in Bitcoin block chain.
	Time int `json:"time"`
}

// Error defines model for Error.
type Error struct {

	// Error code with prefix `btcgw::`.
	Error string `json:"error"`

	// Message to the user.
	ErrorDescription *string `json:"error_description,omitempty"`
}

// BadRequest defines model for BadRequest.
type BadRequest Error

// ErrAnchorNotFound defines model for ErrAnchorNotFound.
type ErrAnchorNotFound Error

// InternalServerError defines model for InternalServerError.
type InternalServerError Error

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Gets the anchor specified by BBc-1 domain ID and BBc-1 transaction ID.
	// (GET /anchors/domains/{dom}/transactions/{tx})
	GetAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
	// Requests to update the status of the anchor specified by BBc-1 domain ID and BBc-1 transaction ID.
	// (PATCH /anchors/domains/{dom}/transactions/{tx})
	PatchAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
	// Registers an anchor with specified BBc-1 domain ID and BBc-1 transaction ID.
	// (POST /anchors/domains/{dom}/transactions/{tx})
	PostAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request, dom string, tx string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) GetAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PatchAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) PatchAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostAnchorsDomainsDomTransactionsTx operation middleware
func (siw *ServerInterfaceWrapper) PostAnchorsDomainsDomTransactionsTx(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "dom" -------------
	var dom string

	err = runtime.BindStyledParameter("simple", false, "dom", chi.URLParam(r, "dom"), &dom)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dom: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tx" -------------
	var tx string

	err = runtime.BindStyledParameter("simple", false, "tx", chi.URLParam(r, "tx"), &tx)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tx: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, ApiKeyScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAnchorsDomainsDomTransactionsTx(w, r, dom, tx)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.GetAnchorsDomainsDomTransactionsTx)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.PatchAnchorsDomainsDomTransactionsTx)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/anchors/domains/{dom}/transactions/{tx}", wrapper.PostAnchorsDomainsDomTransactionsTx)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RXbW/bNhD+KwS3Dx3g2pLj929Jk3VB2y1IM2BDEcQUebbZSqRGnhJ7gf77QFKWrVhd",
	"02Qdtm/i291z5+e5O99TrrNcK1Bo6eyeGrC5Vhb84oSJS/ijAItuxbVCUP6T5XkqOUOpVe+j1crtWb6C",
	"jLmv7w0s6Ix+19uZ7oVT2zszRhtalmWHCrDcyNwZoTN6rm5ZKgUxwSExwEHegugQA1gYZQlTxL/u0rJD",
	"z4w5Vnylzc8af9SFEt8eYfBHlEaycB4/g+xcIRjF0vdgbsEEa1/GBmuW5Sn4z/CEJsiXd7NZoWCdA0cQ",
	"N+GkE27cPERHdjeJv0FWzBLNeWGMy2OeArNAHBDGkRTWw332zxairTzuvLXkpvbmyRXS6b5yo3MwKAPp",
	"koTHQmfus+nq5IS/jInQGZOKnJ8SqcgK1kwAlxlLiUUj1bLr0rPNJR0MR+PJlCU8gkUU948Gw1Hk1wIW",
	"UeTX7jzya3ceVfcFRG5NOxQ3ubMUrLuEOXy4/hw8NExZxt3eIzFuIYpoC3EcbSHG0RZiEm0hDqNxHYJb",
	"t2HkKybVIcQrZpaA5EQi11IRBXinzacumb9jUinAOZlfgUUFeLT7HMxfFMoWea4Ngvihgb161wYBZQYt",
	"CGQGFlmWE8gSEAKESxGugAQ6NFITj+L+YDAd9Se1fakQlmCcg1swVuqWKCudVuddMo/nZN4fDucv0BWW",
	"wgLRKt00IokPPZQd6mqRNCDo7EPtbpvcKsJOzdeaGde1LZ18BI4ObMB0CVwbcUh5Vkvh7zRYCaaioGJt",
	"+W1oxF0huGJIpPVl62HOt0TYI22Tmyu9hBttlq06QN4qg0ObTghfr4vRtD+BmI8G44mIF8MhiJgNxWQE",
	"MUv6g9FoyuLBYjweJ5PxNEmS/pCPB6Ph4GgSR8liGo9adaHVQprMl157iP2VznbHRC8elaRJ/6iNnkpj",
	"y+9zbBKJhplNFfIzfx5IU03utEnFUyQoVe0iSTX/RDyz2yQ4jUdfFEhF4i0xan00c94mjrpHNlUB2+0m",
	"fn+bcC2A3ElckdzAQq7JvGqX82aKql1c3yiNN75vt6WqpaM+9PsOrGVLIKj9j1NYaFYrerVH8XpI6B56",
	"e5C3bVN3EbWkxzVN4IWRuHnvCkHIzXEu38DGfbk6T1fABDgjoSrQ314eX5y/fHP2+847Cy98C5dqobcz",
	"CeNuJik7NJUclPWEqaxcvD1+dXbz0y9vT88uA5/QBxqKzMnVK/KaIdyxDd2rxjTqxt3IXdc5KJZLOqNH",
	"3agb0Q7NGa48/F4gi+2FSmV790JnZW+P6LZ3j+vS3V2CH5ocMzyHzgWd0deAoRza02DhVGd7+bdXjoCN",
	"WbYfRS1j2OZJI2KjmrcMRa8BrSdJCJPYgnOwdlGk6YYwJerhaNf4gjE/kQ0C0jYAdUS9vdHcPzn68pPD",
	"kbns0OFjnLWNtJ6YRZYxs2mLOAcuFxIESTbk4eDmMtA2LXmtsKV1qqia3XXpWGNYBgjGHTxpKKSdIBPH",
	"v51IQtPeSRFNAfvz8LccI8vO08fH9mhw/chg/vl5s7z20uarQ51euO2vVurgsPq+ryX0v9VIhcW6DlLk",
	"giF4xVhkWNTTxrfQj7YtFfRC2/9yCb2EpbQY8BL3PgUE+29U0viQfL8qVuBKG/knBMPPY0TVzn012zby",
	"D9dORftkcfGD8X+gK1L4cWfHjGfRouzQHsvlJ9jYHjfA/LC6vynAZdxtesguhFB/C5PSGaUObmW1Hhjq",
	"fyi7nYtz4seO6/KvAAAA//9g2wgLahIAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
